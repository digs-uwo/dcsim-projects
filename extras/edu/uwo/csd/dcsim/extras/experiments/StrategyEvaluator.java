package edu.uwo.csd.dcsim.extras.experiments;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import edu.uwo.csd.dcsim.*;
import edu.uwo.csd.dcsim.common.ObjectFactory;
import edu.uwo.csd.dcsim.core.Simulation;
import edu.uwo.csd.dcsim.core.metrics.Metric;

public class StrategyEvaluator {

	public static void main(String args[]) {
		
		Simulation.initializeLogging();
		
		StrategyEvaluator stratEval = new StrategyEvaluator();
		
		stratEval.addRandomSeed(6198910678692541341l);
		stratEval.addRandomSeed(5646441053220106016l);
		stratEval.addRandomSeed(-5705302823151233610l);
		stratEval.addRandomSeed(8289672009575825404l);
		stratEval.addRandomSeed(-4637549055860880177l);
		
		try{
			File outputFile = new File("results");
			FileWriter out = new FileWriter(outputFile);
			
			out.write("Beginning brute-force search...\n");
			out.flush();
		
			DescriptiveStatistics balancedStats = stratEval.evaluate(
					new ObjectFactory<DCSimulationTask>() {
	
						@Override
						public DCSimulationTask newInstance() {
							return new BalancedStrategy("balanced");
						}
						
					});
			
			out.write("Balanced: " + balancedStats.getMean() + "\n");
			out.flush();
			
			double slaHighValues[] = {0.004, 0.006, 0.008, 0.01};
			double slaNormalValues[] = {0.001, 0.002, 0.004, 0.006};
			double powerHighValues[] = {1.25, 1.3, 1.4, 1.5};
			double powerNormalValues[] = {1.15, 1.2, 1.25, 1.3};
			
			for (double slaHigh : slaHighValues) {
				for (double slaNormal : slaNormalValues) {
					for (double powerHigh : powerHighValues) {
						for (double powerNormal : powerNormalValues) {
							
							if (slaHigh >= slaNormal && powerHigh >= powerNormal) {
							
								//need to create in-scope final variables for the inner class
								final double fSlaHigh = slaHigh;
								final double fSlaNormal = slaNormal;
								final double fPowerHigh = powerHigh;
								final double fPowerNormal = powerNormal;
								
								DescriptiveStatistics switchStats = stratEval.evaluate(
										new ObjectFactory<DCSimulationTask>() {
						
											@Override
											public DCSimulationTask newInstance() {
												return new SlaPowerStrategySwitching("strat-switching", fSlaHigh, fSlaNormal, fPowerHigh, fPowerNormal);
											}
											
										});
								
								
								out.write("Switching (" + fSlaNormal + ", " +
										fSlaHigh + ", " +
										fPowerNormal + ", " +
										fPowerHigh + ")" +									
										": " + switchStats.getMean() + "\n");
								out.flush();
							}
						}
					}
				}
			}
			
			
			out.close();
		
		} catch(IOException e) {
			e.printStackTrace();
		}
		
	}
	
	
	private ArrayList<Long> randomSeeds = new ArrayList<Long>();

	public void addRandomSeed(long randomSeed) {
		randomSeeds.add(randomSeed);
	}
	
	public void addRandomSeeds(Collection<Long> randomSeeds) {
		randomSeeds.addAll(randomSeeds);
	}
	
	/**
	 * Evaluate a task, generated by a task factory, over the existing set of random seeds added to this object
	 * @param taskFactory
	 * @return
	 */
	public DescriptiveStatistics evaluate(ObjectFactory<DCSimulationTask> taskFactory) {
		return evaluate(randomSeeds, taskFactory);
	}
	
	/**
	 * Evaluate a task, generated by a task factory, over a list of random seeds
	 * @param randomSeeds
	 * @param taskFactory
	 * @return
	 */
	public DescriptiveStatistics evaluate(ArrayList<Long> randomSeeds, ObjectFactory<DCSimulationTask> taskFactory) {
		ArrayList<DCSimulationTask> tasks = new ArrayList<DCSimulationTask>();
		DescriptiveStatistics scoreStats = new DescriptiveStatistics();
		HashMap<DCSimulationTask, Baseline> taskBaselines = new HashMap<DCSimulationTask, Baseline>();
		
		for (Long randomSeed : randomSeeds) {
			DCSimulationTask task = taskFactory.newInstance();
			task.setRandomSeed(randomSeed);
			tasks.add(task);
			
			//get the baseline
			Baseline baseline = Baseline.getBaseline(randomSeed);
			//store the baseline for this task for later use
			taskBaselines.put(task, baseline);
		}	
		
		System.out.println("Executing simulations...");
		
		//execute the simulations in parallel
		SimulationExecutor<DCSimulationTask> executor = new SimulationExecutor<DCSimulationTask>();
		executor.addTasks(tasks);
		executor.execute();
				
		
		System.out.println("Calculating scores...");
		
		//calculate the task scores
		for (DCSimulationTask task : tasks) {
			//score each task using the baseline calculated for it
			scoreStats.addValue(score(task, taskBaselines.get(task)));
		}
		
		System.out.println("done.");
		
		return scoreStats;
	}
	
	/**
	 * Calculate the score for task based on the given baseline
	 * @param task
	 * @param baseline
	 * @return
	 */
	private double score(DCSimulationTask task, Baseline baseline) {
		
		//get the power efficiency and sla values from the task
		double powerEff = extractPowerEfficiency(task.getResults());
		double sla = extractSLA(task.getResults());
		
		//normalize power efficiency and sla values
		double normPowerEff = (baseline.powerHigh - powerEff) / (baseline.powerHigh - baseline.powerLow);
		double normSla = (sla - baseline.slaLow) / (baseline.slaHigh - baseline.slaLow);
		
		//return the distance to the origin
		return Math.sqrt((normPowerEff * normPowerEff) + (normSla * normSla));
	}

	
	/**
	 * Extract power efficiency measurement from collection of metrics
	 * @param metrics
	 * @return power efficiency
	 */
	private static double extractPowerEfficiency(Collection<Metric> metrics){
		for(Metric metric : metrics){
			if(metric.getName().equals("powerEfficiency")){
				return metric.getValue();
			}
		}
		throw new RuntimeException("Could not extract power efficiency from metric collection");
	}
	
	/**
	 * Extract SLA measurement from collection of metrics
	 * @param metrics
	 * @return sla (0% - 100%)
	 */
	private static double extractSLA(Collection<Metric> metrics){
		for(Metric metric : metrics){
			if(metric.getName().equals("slaViolation")){
				return metric.getValue()*100;
			}
		}
		throw new RuntimeException("Could not extract sla from metric collection");
	}
	
	
	public static class Baseline {
		
		//store all previously calculated baselines
		private static HashMap<Long, Baseline> baselines = new HashMap<Long, Baseline>();
		
		public final double slaLow;
		public final double slaHigh;
		public final double powerLow;
		public final double powerHigh;
		
		private Baseline(double slaLow, double slaHigh, double powerLow, double powerHigh) {
			this.slaLow = slaLow;
			this.slaHigh = slaHigh;
			this.powerLow = powerLow;
			this.powerHigh = powerHigh;
		}
		
		public static Baseline getBaseline(long randomSeed) {
			//if we have already generated a baseline for this seed, use it
			if (baselines.containsKey(randomSeed))
				return baselines.get(randomSeed);
			
			System.out.println("Generating baseline for seed " + randomSeed + "...");
			
			//setup power-friendly and sla-friendly strategy simulations with specified random seed
			DCSimulationTask powerTask = new GreenStrategy("power-baseline", randomSeed);
			DCSimulationTask slaTask = new SLAFriendlyStrategy("sla-baseline", randomSeed);
			
			//execute the simulations
			SimulationExecutor<DCSimulationTask> executor = new SimulationExecutor<DCSimulationTask>();
			executor.addTask(powerTask);
			executor.addTask(slaTask);
			executor.execute();
			
			Baseline baseline = new Baseline(extractSLA(slaTask.getResults()),
					extractSLA(powerTask.getResults()),
					extractPowerEfficiency(slaTask.getResults()),
					extractPowerEfficiency(powerTask.getResults()));
			
			baselines.put(randomSeed, baseline);
			
			return baseline;
		}
	}
	
	
	
	
}
