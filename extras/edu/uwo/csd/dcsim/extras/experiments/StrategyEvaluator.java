package edu.uwo.csd.dcsim.extras.experiments;

import java.io.*;
import java.util.*;

import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import edu.uwo.csd.dcsim.*;
import edu.uwo.csd.dcsim.common.ObjectFactory;
import edu.uwo.csd.dcsim.core.Simulation;
import edu.uwo.csd.dcsim.core.metrics.Metric;

public class StrategyEvaluator {

	public static void main(String args[]) {

		Simulation.initializeLogging();
		
		StrategyEvaluator stratEval = new StrategyEvaluator(4);
		
		stratEval.generateRandomSeeds(2, 6198910678692541341l);

	
		DescriptiveStatistics balancedStats = stratEval.evaluate(
				new ObjectFactory<DCSimulationTask>() {

					@Override
					public DCSimulationTask newInstance() {
						return new BalancedStrategy("balanced");
					}
					
				});
	
		DescriptiveStatistics threshStats = stratEval.evaluate(
				new ObjectFactory<DCSimulationTask>() {

					@Override
					public DCSimulationTask newInstance() {
						return new SlaPowerStrategySwitching("thresh-switching", 0.008, 0.004, 1.3, 1.15);
					}
					
				});
		
		DescriptiveStatistics utilStats = stratEval.evaluate(
				new ObjectFactory<DCSimulationTask>() {

					@Override
					public DCSimulationTask newInstance() {
						//UtilStrategySwitching thresholds: toPower=0.0025517241, toSla=0.0025517241
						return new UtilStrategySwitching("util-switching", 0, 0.0025517241, 0.0025517241);
					}
					
				});
		
		
		System.out.println("Balanced: " + balancedStats.getMean() + "\n");
		System.out.println("Thresh-Switching: " + threshStats.getMean() + "\n");
		System.out.println("Util-Switching: " + utilStats.getMean() + "\n");
	
		
	}
	
	
	private ArrayList<Long> randomSeeds = new ArrayList<Long>();
	private int nThreads;
	
	public StrategyEvaluator(int nThreads) {
		this.nThreads = nThreads;
	}
	
	/**
	 * Generate a specific number of random seeds to evaluate strategies on
	 * @param nSeeds
	 */
	public void generateRandomSeeds(int nSeeds) {
		Random random = new Random();
		for (int i = 0; i < nSeeds; ++i) {
			randomSeeds.add(random.nextLong());
		}
	}

	/**
	 * Generate a specific number of random seeds to evaluate strategies on, using a specified
	 * seed to generate the sequence
	 * @param nSeeds
	 */
	public void generateRandomSeeds(int nSeeds, long startingSeed) {
		Random random = new Random(startingSeed);
		for (int i = 0; i < nSeeds; ++i) {
			randomSeeds.add(random.nextLong());
		}
	}
	
	/**
	 * Add a random seed to the list of random seeds that strategies are evaluated on
	 * @param randomSeed
	 */
	public void addRandomSeed(long randomSeed) {
		randomSeeds.add(randomSeed);
	}
	
	/**
	 * Add a collection of random seeds to the list of random seeds that strategies are evaluated on
	 * @param randomSeeds
	 */
	public void addRandomSeeds(Collection<Long> randomSeeds) {
		randomSeeds.addAll(randomSeeds);
	}
	
	/**
	 * Evaluate a task, generated by a task factory, over the existing set of random seeds added to this object
	 * @param taskFactory
	 * @return
	 */
	public DescriptiveStatistics evaluate(ObjectFactory<DCSimulationTask> taskFactory) {
		return evaluate(randomSeeds, taskFactory);
	}
	
	/**
	 * Evaluate a task, generated by a task factory, over a list of random seeds
	 * @param randomSeeds
	 * @param taskFactory
	 * @return
	 */
	public DescriptiveStatistics evaluate(ArrayList<Long> randomSeeds, ObjectFactory<DCSimulationTask> taskFactory) {
		ArrayList<DCSimulationTask> tasks = new ArrayList<DCSimulationTask>();
		DescriptiveStatistics scoreStats = new DescriptiveStatistics();
		DescriptiveStatistics slaScoreStats = new DescriptiveStatistics();
		DescriptiveStatistics powerScoreStats = new DescriptiveStatistics();
		HashMap<DCSimulationTask, Score> taskScores = new HashMap<DCSimulationTask, Score>();
		HashMap<DCSimulationTask, Baseline> taskBaselines = new HashMap<DCSimulationTask, Baseline>();
		String name = "";
		
		//generate the baselines
		Baseline.preloadBaselines(randomSeeds, nThreads);
		
		for (Long randomSeed : randomSeeds) {
			DCSimulationTask task = taskFactory.newInstance();
			task.setRandomSeed(randomSeed);
			tasks.add(task);
			name = task.getName(); //will set the overall evaluation name to that of the last generated task
			
			//get the baseline
			Baseline baseline = Baseline.getBaseline(randomSeed);
			//store the baseline for this task for later use
			taskBaselines.put(task, baseline);
		}	
		
		System.out.println("Executing simulations...");
		
		//execute the simulations in parallel
		SimulationExecutor<DCSimulationTask> executor = new SimulationExecutor<DCSimulationTask>();
		executor.addTasks(tasks);
		executor.execute(nThreads);	
		
		try {
			DCSimulationReport report = new DCSimulationReport(tasks);
			BufferedWriter out = new BufferedWriter(new FileWriter(name + "_full_report.csv"));
			report.writeCsv(out);
			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("Calculating scores...");
		
		//calculate the task scores
		for (DCSimulationTask task : tasks) {
			//score each task using the baseline calculated for it
			Score score = score(task, taskBaselines.get(task));
			taskScores.put(task, score);
			scoreStats.addValue(score.score);
			slaScoreStats.addValue(score.slaScore);
			powerScoreStats.addValue(score.powerScore);
		}
		
		try {
			BufferedWriter out = new BufferedWriter(new FileWriter(name + "_scores_report.csv"));
			
			out.write("task#, slaScore, powerScore, score");
			out.newLine();
			for (int i = 0; i < tasks.size(); ++i) {
				Score score = taskScores.get(tasks.get(i));
				out.write(i + ", " + score.slaScore + ", " + score.powerScore + ", " + score.score);
				out.newLine();
			}
			
			out.write("avg, " + slaScoreStats.getMean() + ", " + powerScoreStats.getMean() + ", " + scoreStats.getMean());
			out.newLine();
			out.write("max, " + slaScoreStats.getMax() + ", " + powerScoreStats.getMax() + ", " + scoreStats.getMax());
			out.newLine();
			out.write("min, " + slaScoreStats.getMin() + ", " + powerScoreStats.getMin() + ", " + scoreStats.getMin());
			out.newLine();
			out.write("stdev, " + slaScoreStats.getStandardDeviation() + ", " + powerScoreStats.getStandardDeviation() + ", " + scoreStats.getStandardDeviation());
			out.newLine();
			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("done.");
		
		return scoreStats;
	}
	
	/**
	 * Calculate the score for task based on the given baseline
	 * @param task
	 * @param baseline
	 * @return
	 */
	private static Score score(DCSimulationTask task, Baseline baseline) {
		
		//get the power efficiency and sla values from the task
		double powerEff = extractPowerEfficiency(task.getResults());
		double sla = extractSLA(task.getResults());
		
		//normalize power efficiency and sla values
		double normPowerEff = (baseline.powerHigh - powerEff) / (baseline.powerHigh - baseline.powerLow);
		double normSla = (sla - baseline.slaLow) / (baseline.slaHigh - baseline.slaLow);
		
		//return the distance to the origin
		return new Score(normSla, normPowerEff);
	}

	
	/**
	 * Extract power efficiency measurement from collection of metrics
	 * @param metrics
	 * @return power efficiency
	 */
	private static double extractPowerEfficiency(Collection<Metric> metrics){
		for(Metric metric : metrics){
			if(metric.getName().equals("powerEfficiency")){
				return metric.getValue();
			}
		}
		throw new RuntimeException("Could not extract power efficiency from metric collection");
	}
	
	/**
	 * Extract SLA measurement from collection of metrics
	 * @param metrics
	 * @return sla (0% - 100%)
	 */
	private static double extractSLA(Collection<Metric> metrics){
		for(Metric metric : metrics){
			if(metric.getName().equals("slaViolation")){
				return metric.getValue()*100;
			}
		}
		throw new RuntimeException("Could not extract sla from metric collection");
	}
	
	public static class Score {
		public final double slaScore;
		public final double powerScore;
		public final double score;
		
		public Score(double slaScore, double powerScore) {
			this.slaScore = slaScore;
			this.powerScore = powerScore;
			score = Math.sqrt((powerScore * powerScore) + (slaScore * slaScore));
		}
	}
	
	public static class Baseline {
		
		//store all previously calculated baselines
		private static HashMap<Long, Baseline> baselines = new HashMap<Long, Baseline>();
		private static boolean fileLoaded = false;
		
		public final double slaLow;
		public final double slaHigh;
		public final double powerLow;
		public final double powerHigh;
		
		private Baseline(double slaLow, double slaHigh, double powerLow, double powerHigh) {
			this.slaLow = slaLow;
			this.slaHigh = slaHigh;
			this.powerLow = powerLow;
			this.powerHigh = powerHigh;
		}
	
		private static void loadFile() {
			File f = new File("baselines.csv");
			
			if (f.exists()) {
				try {
					BufferedReader reader = new BufferedReader(new FileReader(f));
					
					String line;
					while ((line = reader.readLine()) != null) {
						String values[] = line.split(",");
						
						long seed = Long.parseLong(values[0]);
						double slaLow = Double.parseDouble(values[1]);
						double slaHigh = Double.parseDouble(values[2]);
						double powerLow = Double.parseDouble(values[3]);
						double powerHigh = Double.parseDouble(values[4]);
						
						Baseline baseline = new Baseline(slaLow, slaHigh, powerLow, powerHigh);
						baselines.put(seed, baseline);
					}
					
					reader.close();
				} catch (FileNotFoundException e) {
					throw new RuntimeException(e);
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			
		}
		
		private static void writeFile() {
			try {
				BufferedWriter out = new BufferedWriter(new FileWriter("baselines.csv"));
				
				for (Long seed : baselines.keySet()) {
					Baseline baseline = baselines.get(seed);
					out.write(seed + "," + baseline.slaLow + "," + baseline.slaHigh + "," + baseline.powerLow + "," + baseline.powerHigh);
					out.newLine();
				}
				
				out.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			
		}
		
		public static void preloadBaselines(ArrayList<Long> randomSeeds, int nThreads) {
			
			if (!fileLoaded) {
				loadFile();
				fileLoaded = true;
			}
			
			HashMap<Long, DCSimulationTask> powerTasks = new HashMap<Long, DCSimulationTask>();
			HashMap<Long, DCSimulationTask> slaTasks = new HashMap<Long, DCSimulationTask>();
			
			System.out.println("Preloading " + randomSeeds.size() + " baselines...");
			
			for (Long seed : randomSeeds) {
				if (!baselines.containsKey(seed)) {
					//setup power-friendly and sla-friendly strategy simulations with specified random seed
					DCSimulationTask powerTask = new GreenStrategy("power-baseline", seed);
					DCSimulationTask slaTask = new SLAFriendlyStrategy("sla-baseline", seed);
					
					powerTasks.put(seed, powerTask);
					slaTasks.put(seed, slaTask);
				}
			}
			
			SimulationExecutor<DCSimulationTask> executor = new SimulationExecutor<DCSimulationTask>();
			executor.addTasks(powerTasks.values());
			executor.addTasks(slaTasks.values());
			executor.execute(nThreads);
			
			//creates baselines from results
			for (Long seed : randomSeeds) {
				if (!baselines.containsKey(seed)) {
					DCSimulationTask powerTask = powerTasks.get(seed);
					DCSimulationTask slaTask = slaTasks.get(seed);
					
					Baseline baseline = new Baseline(extractSLA(slaTask.getResults()),
							extractSLA(powerTask.getResults()),
							extractPowerEfficiency(slaTask.getResults()),
							extractPowerEfficiency(powerTask.getResults()));
					
					baselines.put(seed, baseline);
				}
			}
			
			writeFile();
		}
		
		public static Baseline getBaseline(long randomSeed) {
			
			if (!fileLoaded) {
				loadFile();
				fileLoaded = true;
			}
			
			//if we have already generated a baseline for this seed, use it
			if (baselines.containsKey(randomSeed))
				return baselines.get(randomSeed);
			
			System.out.println("Generating baseline for seed " + randomSeed + "...");
			
			//setup power-friendly and sla-friendly strategy simulations with specified random seed
			DCSimulationTask powerTask = new GreenStrategy("power-baseline", randomSeed);
			DCSimulationTask slaTask = new SLAFriendlyStrategy("sla-baseline", randomSeed);
			
			//execute the simulations
			SimulationExecutor<DCSimulationTask> executor = new SimulationExecutor<DCSimulationTask>();
			executor.addTask(powerTask);
			executor.addTask(slaTask);
			executor.execute();
			
			Baseline baseline = new Baseline(extractSLA(slaTask.getResults()),
					extractSLA(powerTask.getResults()),
					extractPowerEfficiency(slaTask.getResults()),
					extractPowerEfficiency(powerTask.getResults()));
			
			baselines.put(randomSeed, baseline);
			
			writeFile();
			
			return baseline;
		}
	}
	
	
	
	
}
